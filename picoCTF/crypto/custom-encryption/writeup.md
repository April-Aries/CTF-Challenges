# Transformation

| Information | Description |
| :-- | :-- |
| Category | Crypto |
| Difficulty | Medium |

# Problem Description

Can you get sense of this code file and write the function that will decode the given encrypted file content. Find the encrypted file `enc_flag` and code file `custom_encryption.py` might be good to analyze and get the flag.

# Solution

The problem provides a custom encryption algorithm. Developing the decrease algorithm leads to the flag. I wrote a python script `exp.py` to decrypt the encrypted flag.

Let's dive into the encryption algorithm then check how do we break it.

There are 3 steps in `custom_encryption.py`.
1. `test(plain_text, text_key) -> cipher`
    * `plain_text` is the flag I want, which is provided by running `python3 custom_encryption.py <flag>`.
    * `text_key` is a constant string `trudeau`.
    * `test` will generate a `shared_key` using 4 integers `p`, `g`, `a`, `b`. `p` and `g` are constants 97 and 31, respectively while `a` and `b` are randomly chosen based on `p` and `g`. However, both `a` and `b` are given.
2. `dynamic_xor_encrypt(plain_text, text_key) -> cipher_text`
    * `plain_text` is still the flag I want.
    * `text_key` is a constant string `trudeau`.
    * `dynamic_xor_encrypt` will generate a `semi_cipher` by XOR each character in `plain_text` (flag) and `text_key` ("trudeau") in reverse order.
3. `encrypt(plaintext, key) -> cipher`
    * `plain_text` is the `semi_cipher` generated by `dynamic_xor_encryption`.
    * `key` is the `shared_key` generated from `test`.
    * `encrypt` will transform each character into ASCII code and times 311 times `key`.
    * The output `cipher` is in an integer array format.

I will address the process into an easier and understandable version of algorithms
- `test(flag, "trudeau") -> cipher_text`
    - `dynamic_xor_encryption(flag, "trudeau") -> semi_cipher`
    - `encrypt(semi_cipher, shared_key) -> cipher_text`

To break the encryption algorithm, I reverse the process and slightly adjust the operations.

I write three reverse functions as decryption algorithm.

| function | reverse function |
| :-- | :-- |
| `test` | `rev_test` |
| `dynamic_xor_encryption` | `dynamic_xor_decryption` |
| `encrypt` | `decrypt` |

`rev_test`first generates `shared_key`. It is easy to generate it since `p` and `g` are constants while `a` and `b` are given. It is okay if `a` and `b` are unknown since there are rarely 100 possibilities. Then I reproduce the `semi_flag` by `decrypt` and getting the flag via `dynamic_xor_decryption`.

Different with `encrypt`, `decrypt` runs division instead of multiplication. The other differences is I treat each element of `cipher` as integer and transform them back to characters.

As for `dynamic_xor_decrypt`, I ask the `semi_cipher` to XOR the `text_key` again so that I can get the flag. The key idea is `A ^ A = 0`, namely, `A ^ B ^ B = A`.
